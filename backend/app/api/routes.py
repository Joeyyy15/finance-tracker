from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import func

# importing database session and models/schemas
from app.db.db_setup import SessionLocal
from app.models.transaction import Transaction, Category, Goal
from app.schemas.transaction import (
    TransactionCreate, TransactionOut,
    CategoryCreate, CategoryOut,
    TransactionUpdate, CategoryTotal,
    GoalCreate, GoalUpdate, GoalOut
)


router = APIRouter()

# gets a database session for each request
def get_db():
    db = SessionLocal()
    try:
        yield db # gives back the database session to the route
    finally:
        db.close() # makes sure the DB session is always closed

# POST route to create a new transaction
@router.post("/transactions", response_model=TransactionOut)
def create_transaction(
    transaction: TransactionCreate, #incoming request body
    db: Session = Depends(get_db)   #get the database session
):  
    # creates a new transaction model instance
    new_transaction = Transaction(
        amount = transaction.amount,
        category_id=transaction.category_id
    )

    # Add it to the database
    db.add(new_transaction)
    db.commit()                  #save the changes
    db.refresh(new_transaction)  #reload to get the new autogenerated ID and date

    # Return the newly created transaction (coverted using schema)
    return new_transaction

# GET route to return all transactions from the database
@router.get("/transactions", response_model=list[TransactionOut])
def get_transactions(db: Session = Depends(get_db)):
    # Query the database to get all transaction rows
    transactions = db.query(Transaction).all()

    # Return the full list of transactions
    return transactions

# updates transactions
@router.put("/transactions/{tx_id}", response_model=TransactionOut)
def update_transaction(tx_id: int, payload: TransactionUpdate, db: Session = Depends(get_db)):
    #update an existing transaction.
    tx = db.query(Transaction).filter(Transaction.id == tx_id).first()
    if not tx:
        raise HTTPException(status_code=404, detail="Transaction not found.")
    
    if payload.amount is not None:
        tx.amount = payload.amount
    
    if payload.category_id is not None:
        # validates that new category exists
        category = db.query(Category).filter(Category.id == payload.category_id).first()
        if not category:
            raise HTTPException(status_code=404, detail="Category not fouhnd.")
        tx.category_id = payload.category_id
    db.commit()
    db.refresh(tx)
    return tx

# deletes transactions
@router.delete("/transactions/{tx_id}")
def delete_transaction(tx_id: int, db: Session = Depends(get_db)):
    # Deletes transaction by ID
    tx = db.query(Transaction).filter(Transaction.id == tx_id).first()
    if not tx:
        raise HTTPException(status_code = 404, detail="Transaction not found.")
    
    db.delete(tx)
    db.commit()
    return {"message": f"Transaction {tx_id} deleted."}

# POST route to create categories
@router.post("/categories", response_model = CategoryOut)
def create_category(category: CategoryCreate, db: Session = Depends(get_db)):
    db_category = Category(name=category.name)
    db.add(db_category)
    db.commit()
    db.refresh(db_category)
    return db_category

# GET route to retrieve categories
@router.get("/categories", response_model=list[CategoryOut])
def get_categories(db: Session = Depends(get_db)):
    return db.query(Category).all()

# returns summaries of total spending depending on category
@router.get("/reports/totals", response_model=list[CategoryTotal])
def get_totals_by_category(db: Session = Depends(get_db)):
    results = (
        db.query(Category.name, func.sum(Transaction.amount).label("total"))
        .join(Transaction, Transaction.category_id == Category.id)
        .group_by(Category.name)
        .all()
    )
    return [{"category": name, "total": total} for name, total in results]

# goals for user
#creates the weekly spending goal for a category
@router.post("/goals", response_model=GoalOut)
def create_goal(payload: GoalCreate, db: Session = Depends(get_db)):
    category = db.query(Category).filter(Category.id == payload.category_id).first()
    if not category:
        raise HTTPException(status_code=404, detail="Category not found.")
    
    #one goal per category
    existing = db.query(Goal).filter(Goal.category_id == payload.category_id).first()
    if existing:
        raise HTTPException (status_code=400, detail="Goal already created for this category.")
    
    goal = Goal(category_id=payload.category_id, weekly_budget=payload.weekly_budget)

    db.add(goal)
    db.commit()
    db.refresh(goal)
    return goal

#lists all goals with their linked categories
@router.get("/goals", response_model=list[GoalOut])
def list_goals(db: Session = Depends(get_db)):
    return db.query(Goal).all()

#update an existing goals weekly_budget.
@router.put("/goals/{goal_id}", response_model=GoalOut)
def update_goal(goal_id: int, payload: GoalUpdate, db: Session = Depends(get_db)):
    goal = db.query(Goal).filter(Goal.id == goal_id).first()
    if not goal:
        raise HTTPException(status_code=404, detail="Goal not found.")
    
    if payload.weekly_budget is not None:
        goal.weekly_budget = payload.weekly_budget
    
    db.commit()
    db.refresh(goal)
    return goal

