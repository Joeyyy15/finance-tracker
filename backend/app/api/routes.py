from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import func
from datetime import date, timedelta, datetime, timezone
from decimal import Decimal

# importing database session and models/schemas
from app.db.db_setup import SessionLocal
from app.models.transaction import Transaction, Category, Goal
from app.schemas.transaction import (
    TransactionCreate, TransactionOut,
    CategoryCreate, CategoryOut,
    TransactionUpdate, CategoryTotal,
    GoalCreate, GoalUpdate, GoalOut, GoalProgress
)


router = APIRouter()

# gets a database session for each request
def get_db():
    db = SessionLocal()
    try:
        yield db # gives back the database session to the route
    finally:
        db.close() # makes sure the DB session is always closed

# POST route to create a new transaction
@router.post("/transactions", response_model=TransactionOut)
def create_transaction(
    transaction: TransactionCreate, #incoming request body
    db: Session = Depends(get_db)   #get the database session
):  
    
    category = db.query(Category).filter(Category.id == transaction.category_id).first()
    if not category:
        raise HTTPException(status_code=400, detail="Category does not exist.")

    tx_date = getattr(transaction, "date", None) or date.today()
    # creates a new transaction model instance
    new_transaction = Transaction(
        amount = transaction.amount,
        category_id=transaction.category_id
    )

    # Add it to the database
    db.add(new_transaction)
    db.commit()                  #save the changes
    db.refresh(new_transaction)  #reload to get the new autogenerated ID and date

    # Return the newly created transaction (coverted using schema)
    return new_transaction

# GET route to return all transactions from the database
@router.get("/transactions", response_model=list[TransactionOut])
def get_transactions(db: Session = Depends(get_db)):
    # Query the database to get all transaction rows
    transactions = db.query(Transaction).all()

    # Return the full list of transactions
    return transactions

# updates transactions
@router.put("/transactions/{tx_id}", response_model=TransactionOut)
def update_transaction(tx_id: int, payload: TransactionUpdate, db: Session = Depends(get_db)):
    #update an existing transaction.
    tx = db.query(Transaction).filter(Transaction.id == tx_id).first()
    if not tx:
        raise HTTPException(status_code=404, detail="Transaction not found.")
    
    if payload.amount is not None:
        tx.amount = payload.amount
    
    if payload.category_id is not None:
        # validates that new category exists
        category = db.query(Category).filter(Category.id == payload.category_id).first()
        if not category:
            raise HTTPException(status_code=404, detail="Category not found.")
        tx.category_id = payload.category_id
    

    db.commit()
    db.refresh(tx)
    return tx

# deletes transactions
@router.delete("/transactions/{tx_id}")
def delete_transaction(tx_id: int, db: Session = Depends(get_db)):
    # Deletes transaction by ID
    tx = db.query(Transaction).filter(Transaction.id == tx_id).first()
    if not tx:
        raise HTTPException(status_code = 404, detail="Transaction not found.")
    
    db.delete(tx)
    db.commit()
    return {"message": f"Transaction {tx_id} deleted."}

# POST route to create categories
@router.post("/categories", response_model = CategoryOut)
def create_category(category: CategoryCreate, db: Session = Depends(get_db)):
    existing = db.query(Category).filter(Category.name == category.name).first()
    if existing:
        raise HTTPException(status_code=409, detail="Category already created")
    db_category = Category(name=category.name, type=category.type)
    db.add(db_category)
    db.commit()
    db.refresh(db_category)
    return db_category

# GET route to retrieve categories
@router.get("/categories", response_model=list[CategoryOut])
def get_categories(db: Session = Depends(get_db)):
    return db.query(Category).all()

# returns summaries of total spending depending on category
@router.get("/reports/totals", response_model=list[CategoryTotal])
def get_totals_by_category(
    start: datetime | None = Query(None),
    end: datetime | None = Query(None),
    db: Session = Depends(get_db),
):
    q = (
        db.query(
            Category.name.label("category"),
            func.sum(Transaction.amount).label("total"),
        )
        .join(Transaction, Transaction.category_id == Category.id)
        .group_by(Category.name)
        .order_by(Category.name.asc())
    )

    if start:
        q = q.filter(Transaction.date >= start)
    if end:
        q = q.filter(Transaction.date <= end)
    
    results = q.all()
    return [
        {"category": name, "total": Decimal(str(total or 0))}
        for name, total in results
    ]

# goals for user
#creates the weekly spending goal for a category
@router.post("/goals", response_model=GoalOut)
def create_goal(payload: GoalCreate, db: Session = Depends(get_db)):
    category = db.query(Category).filter(Category.id == payload.category_id).first()
    if not category:
        raise HTTPException(status_code=404, detail="Category not found.")
    
    #one goal per category
    existing = db.query(Goal).filter(Goal.category_id == payload.category_id).first()
    if existing:
        raise HTTPException (status_code=400, detail="Goal already created for this category.")
    
    goal = Goal(category_id=payload.category_id, weekly_budget=payload.weekly_budget)

    db.add(goal)
    db.commit()
    db.refresh(goal)
    return goal

#lists all goals with their linked categories
@router.get("/goals", response_model=list[GoalOut])
def list_goals(db: Session = Depends(get_db)):
    return db.query(Goal).all()

#update an existing goals weekly_budget.
@router.put("/goals/{goal_id}", response_model=GoalOut)
def update_goal(goal_id: int, payload: GoalUpdate, db: Session = Depends(get_db)):
    goal = db.query(Goal).filter(Goal.id == goal_id).first()
    if not goal:
        raise HTTPException(status_code=404, detail="Goal not found.")
    
    if payload.weekly_budget is not None:
        goal.weekly_budget = payload.weekly_budget
    
    db.commit()
    db.refresh(goal)
    return goal

#setting up goal bars with colors showing when user is getting close to their spending goal
@router.get("/goals/progress", response_model=list[GoalProgress])
def goal_progress(
    start: datetime | None = Query(None),
    end: datetime | None = Query(None),
    db: Session = Depends(get_db)
):

    #defaults user to current week if no time is set for goal
    if not start or not end:
        today = datetime.now(timezone.utc).date()
        monday = today - timedelta(days=today.weekday())
        sunday = monday + timedelta(days=6)
        start = datetime.combine(monday, datetime.min.time(), tzinfo=timezone.utc)
        end = datetime.combine(sunday, datetime.max.time(), tzinfo=timezone.utc)

    #Joing goals to categories, left join transactions in range
    rows = (
        db.query(
            Goal.category_id.label("category_id"),
            Category.name.label("category_name"),
            Goal.weekly_budget.label("weekly_budget"),
            func.coalesce(func.sum(Transaction.amount),0).label("spent"),
        )
        .join(Category, Category.id == Goal.category_id)
        .outerjoin(
            Transaction,
            (Transaction.category_id == Goal.category_id)&
            (Transaction.date >= start) & 
            (Transaction.date <= end)
        )
        .group_by(Goal.category_id, Category.name, Goal.weekly_budget)
        .order_by(Category.name.asc())
        .all()
    )

    result = []
    for category_id, category_name, weekly_budget, spent in rows:
        spent = Decimal(str(spent or 0))
        budget = Decimal(str(weekly_budget))
        pct = (spent / budget * Decimal("100")) if budget > 0 else Decimal("0")
        if pct < 70:
            status = "green"
        elif pct <= 100:
            status = "yellow"
        else:
            status = "red"
        result.append({
            "category_id": category_id,
            "category_name": category_name,
            "spent": spent,
            "weekly_budget": budget,
            "pct_used": pct.quantize(Decimal("0.01")),
            "status": status,
        })
    return result
