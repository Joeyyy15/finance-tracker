from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

# importing database session and models/schemas
from app.db.db_setup import SessionLocal
from app.models.transaction import Transaction, Category
from app.schemas.transaction import (
    TransactionCreate, TransactionOut,
    CategoryCreate, CategoryOut,
    TransactionUpdate,  
)


router = APIRouter()

# gets a database session for each request
def get_db():
    db = SessionLocal()
    try:
        yield db # gives back the database session to the route
    finally:
        db.close() # makes sure the DB session is always closed

# POST route to create a new transaction
@router.post("/transactions", response_model=TransactionOut)
def create_transaction(
    transaction: TransactionCreate, #incoming request body
    db: Session = Depends(get_db)   #get the database session
):  
    # creates a new transaction model instance
    new_transaction = Transaction(
        amount = transaction.amount,
        category_id=transaction.category_id
    )

    # Add it to the database
    db.add(new_transaction)
    db.commit()                  #save the changes
    db.refresh(new_transaction)  #reload to get the new autogenerated ID and date

    # Return the newly created transaction (coverted using schema)
    return new_transaction

# GET route to return all transactions from the database
@router.get("/transactions", response_model=list[TransactionOut])
def get_transactions(db: Session = Depends(get_db)):
    # Query the database to get all transaction rows
    transactions = db.query(Transaction).all()

    # Return the full list of transactions
    return transactions

@router.put("/transactions/{tx_id}", response_model=TransactionOut)
def update_transaction(tx_id: int, payload: TransactionUpdate, db: Session = Depends(get_db)):
    #update an existing transaction.
    tx = db.query(Transaction).filter(Transaction.id == tx_id).first()
    if not tx:
        raise HTTPException(status_code=404, detail="Transaction not found.")
    
    if payload.amount is not None:
        tx.amount = payload.amount
    
    if payload.category_id is not None:
        # validates that new category exists
        category = db.query(Category).filter(Category.id == payload.category_id).first()
        if not category:
            raise HTTPException(status_code=404, detail="Category not fouhnd.")
        tx.category_id = payload.category_id
    db.commit()
    db.refresh(tx)
    return tx

@router.delete("/transactions/{tx_id}")
def delete_transaction(tx_id: int, db: Session = Depends(get_db)):
    # Deletes transaction by ID
    tx = db.query(Transaction).filter(Transaction.id == tx_id).first()
    if not tx:
        raise HTTPException(status_code = 404, detail="Transaction not found.")
    
    db.delete(tx)
    db.commit()
    return {"message": f"Transaction {tx_id} deleted."}
# POST route to create categories
@router.post("/categories", response_model = CategoryOut)
def create_category(category: CategoryCreate, db: Session = Depends(get_db)):
    db_category = Category(name=category.name)
    db.add(db_category)
    db.commit()
    db.refresh(db_category)
    return db_category

# GET route to retrieve categories
@router.get("/categories", response_model=list[CategoryOut])
def get_categories(db: Session = Depends(get_db)):
    return db.query(Category).all()